<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>天体シミュレーター v2.6.1</title>
    <style>
        body { font-family: sans-serif; background: #000; color: white; margin: 0; overflow: hidden; }
        canvas { display: block; background: #000510; touch-action: none; }
        .ui-panel { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.9); padding: 12px; border-radius: 10px; border: 1px solid #444; z-index: 100; width: 230px; }
        .time-panel { position: absolute; bottom: 20px; left: 10px; background: rgba(0,0,0,0.9); padding: 10px; border-radius: 10px; border: 1px solid #444; z-index: 100; }
        .view-panel { position: absolute; bottom: 20px; right: 20px; background: #000; padding: 12px; border-radius: 10px; border: 2px solid #444; text-align: center; width: 360px; z-index: 110; }
        .cross-layout { display: grid; grid-template-areas: ". up ." "left . right" ". down ."; gap: 5px; justify-items: center; }
        .cross-layout button { padding: 5px; font-size: 0.75rem; min-width: 60px; }
        .btn-up { grid-area: up; } .btn-down { grid-area: down; } .btn-left { grid-area: left; } .btn-right { grid-area: right; }
        .control-group { margin-bottom: 12px; border-bottom: 1px solid #333; padding-bottom: 8px; }
        #time-display { color: #ffff00; font-weight: bold; font-size: 0.9rem; }
        input[type="range"] { width: 100%; cursor: pointer; }
        button { background: #333; color: white; border: 1px solid #666; padding: 8px; cursor: pointer; border-radius: 4px; }
        button.active { background: #550000; border-color: #f33; }
        button.sun-active { background: #885500; border-color: #ffaa00; }
        #view-canvas { border: 1px solid #333; margin-top: 5px; border-radius: 5px; background: #000; width: 340px; height: 160px; }
        .phase-display { text-align: center; margin-top: 5px; color: #00ffff; font-weight: bold; font-size: 1.1rem; }
        .distance-display { text-align: center; font-size: 0.85rem; color: #ffaa00; margin-top: 5px; }
        .version-tag { position: absolute; top: 5px; right: 10px; font-size: 0.65rem; color: #666; }
    </style>
</head>
<body>

<div class="ui-panel">
    <div class="version-tag">v2.6.1</div>
    <h3 style="margin:0 0 10px 0; font-size: 0.95rem;">天体の満ち欠け学習</h3>
    <div class="control-group">
        <div style="display:flex; justify-content:space-between;"><label style="font-size:0.75rem;">向き:</label><div id="time-display">昼間 (12:00)</div></div>
        <input type="range" id="person-pos" min="0" max="360" value="0">
    </div>
    <div class="control-group">
        <button id="auto-btn" style="width:100%; font-size:0.8rem; margin-bottom:5px;">自動公転: OFF</button>
        <button id="sun-toggle-btn" style="width:100%; font-size:0.8rem;">太陽の位置表示: OFF</button>
        <div id="phase-text" class="phase-display">--</div>
        <div id="dist-text" class="distance-display">距離: -- km</div>
    </div>
</div>

<div class="time-panel">
    <div class="cross-layout">
        <button class="btn-up" onclick="setTime(90)">18:00<br>夕方</button>
        <button class="btn-left" onclick="setTime(180)">24:00<br>真夜中</button>
        <button class="btn-right" onclick="setTime(0)">12:00<br>昼間</button>
        <button class="btn-down" onclick="setTime(270)">06:00<br>明け方</button>
    </div>
</div>

<div class="view-panel">
    <div style="font-size: 0.75rem; color: #ccc;">地上から見た空（南向き）</div>
    <canvas id="view-canvas" width="340" height="160"></canvas>
    <div style="display:flex; justify-content:space-between; font-size:0.7rem; color:#aaa; padding:0 10px;">
        <span>東</span><span>南（正面）</span><span>西</span>
    </div>
</div>

<canvas id="mainCanvas"></canvas>

<script>
const canvas = document.getElementById('mainCanvas'), ctx = canvas.getContext('2d');
const vCanvas = document.getElementById('view-canvas'), vCtx = vCanvas.getContext('2d');

let isAutoOrbit = false, showSunInView = false, showMars = false;
let venusAngle = 0, marsAngle = 1, personAngle = 0;
let orbitSpeed = 0.01, marsOrbitSpeed = 0.0053;
let earthClickCount = 0;

const sunX = 50, sunY = 0; 
const earthX = -380, earthY = 0; 
const orbitRadius = 180;      
const marsOrbitRadius = 600; 
const earthR = 50, venusBaseR = 16, marsBaseR = 14;
const AU_KM = 149600000;

function setTime(val) {
    document.getElementById('person-pos').value = val;
    personAngle = -(val * Math.PI / 180);
    const td = document.getElementById('time-display');
    if (val < 45 || val >= 315) td.innerText = "昼間 (12:00)";
    else if (val >= 45 && val < 110) td.innerText = "夕方 (18:00)";
    else if (val >= 110 && val < 230) td.innerText = "真夜中 (24:00)";
    else td.innerText = "明け方 (06:00)";
}

function init() {
    window.addEventListener('resize', resize); resize();
    document.getElementById('person-pos').oninput = function() { setTime(parseInt(this.value)); };
    document.getElementById('auto-btn').onclick = function() { 
        isAutoOrbit = !isAutoOrbit; this.innerText = `自動公転: ${isAutoOrbit ? 'ON' : 'OFF'}`;
        this.classList.toggle('active', isAutoOrbit);
    };
    document.getElementById('sun-toggle-btn').onclick = function() {
        showSunInView = !showSunInView; this.innerText = `太陽の位置表示: ${showSunInView ? 'ON' : 'OFF'}`;
        this.classList.toggle('sun-active', showSunInView);
    };

    let draggingTarget = null;

    canvas.addEventListener('pointerdown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scale = showMars ? 0.6 : 1.0;
        const mx = (e.clientX - rect.left - canvas.width/2) / scale;
        const my = (e.clientY - rect.top - canvas.height/2) / scale;

        const distToEarth = Math.sqrt((mx - earthX)**2 + (my - earthY)**2);
        if (distToEarth < earthR && mx < earthX) {
            earthClickCount++;
            if (earthClickCount >= 5) { showMars = !showMars; earthClickCount = 0; }
            return;
        }

        const vx = sunX + Math.cos(venusAngle) * orbitRadius, vy = sunY + Math.sin(venusAngle) * orbitRadius;
        if (Math.sqrt((mx - vx)**2 + (my - vy)**2) < 30) { draggingTarget = 'venus'; return; }
        if (showMars) {
            const marsX = sunX + Math.cos(marsAngle) * marsOrbitRadius, marsY = sunY + Math.sin(marsAngle) * marsOrbitRadius;
            if (Math.sqrt((mx - marsX)**2 + (my - marsY)**2) < 30) { draggingTarget = 'mars'; return; }
        }
    });

    window.addEventListener('pointermove', (e) => {
        if (!draggingTarget) return;
        const rect = canvas.getBoundingClientRect();
        const scale = showMars ? 0.6 : 1.0;
        const mx = (e.clientX - rect.left - canvas.width/2) / scale;
        const my = (e.clientY - rect.top - canvas.height/2) / scale;
        const ang = Math.atan2(my - sunY, mx - sunX);
        if (draggingTarget === 'venus') venusAngle = ang;
        else if (draggingTarget === 'mars') marsAngle = ang;
    });

    window.addEventListener('pointerup', () => { draggingTarget = null; });
    requestAnimationFrame(update);
}

function update() {
    if (isAutoOrbit) { venusAngle -= orbitSpeed; marsAngle -= marsOrbitSpeed; }
    draw();
    drawGroundView();
    requestAnimationFrame(update);
}

function drawPlanetObject(targetCtx, r, phaseAngle, isSpaceView, rotation = 0, type = 'venus', planetAngle = 0) {
    targetCtx.save();
    if (rotation !== 0) targetCtx.rotate(rotation);
    if (type === 'sun') {
        targetCtx.fillStyle = "#ffcc00"; targetCtx.shadowBlur = 15; targetCtx.shadowColor = "#ffaa00";
        targetCtx.beginPath(); targetCtx.arc(0, 0, r, 0, Math.PI * 2); targetCtx.fill();
        targetCtx.restore(); return;
    }

    const baseColor = type === 'mars' ? "#441111" : "#111";
    const lightColor = type === 'mars' ? "#ff5533" : "#eee";

    if (isSpaceView) {
        targetCtx.rotate(planetAngle + Math.PI);
        targetCtx.beginPath(); targetCtx.arc(0, 0, r, 0, Math.PI * 2); targetCtx.fillStyle = baseColor; targetCtx.fill();
        targetCtx.beginPath(); targetCtx.arc(0, 0, r, -Math.PI/2, Math.PI/2, false);
        targetCtx.fillStyle = lightColor; targetCtx.fill();
    } else {
        const s = Math.cos(phaseAngle), isLeftLight = Math.sin(phaseAngle) < 0;
        targetCtx.beginPath(); targetCtx.arc(0, 0, r, 0, Math.PI * 2); targetCtx.fillStyle = baseColor; targetCtx.fill();
        targetCtx.beginPath(); targetCtx.arc(0, 0, r, -Math.PI/2, Math.PI/2, isLeftLight);
        targetCtx.fillStyle = lightColor; targetCtx.fill();
        targetCtx.beginPath(); targetCtx.ellipse(0, 0, r * Math.abs(s), r, 0, 0, Math.PI * 2);
        targetCtx.fillStyle = s > 0 ? baseColor : lightColor; targetCtx.fill();
    }
    targetCtx.restore();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const scale = showMars ? 0.6 : 1.0;
    
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.scale(scale, scale);

    ctx.strokeStyle = "rgba(255,255,255,0.15)"; ctx.lineWidth = 1/scale;
    ctx.beginPath(); ctx.arc(sunX, sunY, orbitRadius, 0, Math.PI*2); ctx.stroke();
    if (showMars) {
        ctx.strokeStyle = "rgba(255,50,50,0.5)"; ctx.lineWidth = 2/scale;
        ctx.beginPath(); ctx.arc(sunX, sunY, marsOrbitRadius, 0, Math.PI*2); ctx.stroke();
    }

    ctx.save(); ctx.translate(sunX, sunY); drawPlanetObject(ctx, 50, 0, true, 0, 'sun'); ctx.restore();

    const vx = sunX + Math.cos(venusAngle)*orbitRadius, vy = sunY + Math.sin(venusAngle)*orbitRadius;
    const mx = sunX + Math.cos(marsAngle)*marsOrbitRadius, my = sunY + Math.sin(marsAngle)*marsOrbitRadius;

    ctx.save();
    ctx.translate(earthX, earthY);
    ctx.fillStyle = '#1e90ff'; ctx.beginPath(); ctx.arc(0, 0, earthR, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.beginPath(); ctx.arc(0, 0, earthR + 0.5, Math.PI/2, 3*Math.PI/2, false); ctx.fill();
    
    ctx.save(); ctx.rotate(personAngle);
    
    ctx.setLineDash([4/scale, 4/scale]); ctx.lineWidth = 1/scale;
    const vdx = vx - earthX, vdy = vy - earthY;
    const vRelX = vdx * Math.cos(-personAngle) - vdy * Math.sin(-personAngle);
    const vRelY = vdx * Math.sin(-personAngle) + vdy * Math.cos(-personAngle);
    ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.beginPath(); ctx.moveTo(earthR, 0); ctx.lineTo(vRelX, vRelY); ctx.stroke();
    
    if (showMars) {
        const mdx = mx - earthX, mdy = my - earthY;
        const mRelX = mdx * Math.cos(-personAngle) - mdy * Math.sin(-personAngle);
        const mRelY = mdx * Math.sin(-personAngle) + mdy * Math.cos(-personAngle);
        ctx.strokeStyle = "rgba(255,100,100,0.6)"; ctx.beginPath(); ctx.moveTo(earthR, 0); ctx.lineTo(mRelX, mRelY); ctx.stroke();
    }
    ctx.setLineDash([]);

    ctx.translate(earthR, 0); 
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 3/scale; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(25/scale, 0); ctx.stroke();
    
    ctx.save();
    ctx.rotate(Math.PI/2);
    ctx.strokeStyle = "white"; ctx.lineWidth = 1.5/scale;
    ctx.beginPath(); ctx.arc(0, -12/scale, 3/scale, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, -9/scale); ctx.lineTo(0, -3/scale); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-4/scale, -7/scale); ctx.lineTo(4/scale, -7/scale); ctx.stroke();
    ctx.restore();

    ctx.strokeStyle = "rgba(255,255,255,0.7)"; ctx.lineWidth = 1/scale;
    ctx.beginPath(); ctx.moveTo(0, -40); ctx.lineTo(0, 40); ctx.stroke();
    ctx.fillStyle = "#00ff00"; ctx.font = `bold ${12/scale}px sans-serif`; ctx.textAlign = "center";
    ctx.save(); ctx.translate(0, -50); ctx.rotate(Math.PI/2); ctx.fillText("東", 0, 0); ctx.restore();
    ctx.save(); ctx.translate(0, 50); ctx.rotate(Math.PI/2); ctx.fillText("西", 0, 0); ctx.restore();
    ctx.restore(); ctx.restore();

    ctx.save(); ctx.translate(vx, vy); drawPlanetObject(ctx, venusBaseR, 0, true, 0, 'venus', venusAngle); ctx.restore();
    if (showMars) {
        ctx.save(); ctx.translate(mx, my); drawPlanetObject(ctx, marsBaseR, 0, true, 0, 'mars', marsAngle); ctx.restore();
    }
    
    ctx.restore();

    // 明星の判定: ラジアン角が負（画面上半分）なら「よいの明星」
    document.getElementById('phase-text').innerText = (Math.sin(venusAngle) < 0) ? "よいの明星" : "明けの明星";
}

function drawGroundView() {
    vCtx.clearRect(0, 0, vCanvas.width, vCanvas.height);
    const deg = (parseInt(document.getElementById('person-pos').value) % 360 + 360) % 360;
    let sky = "#000015";
    if (deg < 35 || deg > 325) sky = "#4488ff"; 
    else if (deg < 65) sky = "#cc4422"; 
    else if (deg < 110) sky = "#442244"; 
    else if (deg < 250) sky = "#000015"; 
    else if (deg < 290) sky = "#442266"; 
    else sky = "#6655aa";
    vCanvas.style.background = sky;

    let queue = [];
    if (showSunInView) {
        const dx = sunX - earthX, dy = sunY - earthY;
        const ang = Math.atan2(dy, dx), dist = Math.sqrt(dx*dx + dy*dy);
        let diff = ang - personAngle; while (diff < -Math.PI) diff += Math.PI * 2; while (diff > Math.PI) diff -= Math.PI * 2;
        if (Math.abs(diff) < Math.PI / 2) queue.push({ type: 'sun', dist, diff });
    }
    const vdx = sunX + Math.cos(venusAngle)*orbitRadius - earthX, vdy = sunY + Math.sin(venusAngle)*orbitRadius - earthY;
    const vAng = Math.atan2(vdy, vdx), vDist = Math.sqrt(vdx*vdx + vdy*vdy);
    document.getElementById('dist-text').innerText = `距離: ${Math.floor((vDist/100)*AU_KM).toLocaleString()} km`;
    let vDiff = vAng - personAngle; while (vDiff < -Math.PI) vDiff += Math.PI * 2; while (vDiff > Math.PI) vDiff -= Math.PI * 2;
    if (Math.abs(vDiff) < Math.PI / 2) queue.push({ type: 'venus', dist: vDist, diff: vDiff, ang: vAng, pAng: venusAngle });

    if (showMars) {
        const mdx = sunX + Math.cos(marsAngle)*marsOrbitRadius - earthX, mdy = sunY + Math.sin(marsAngle)*marsOrbitRadius - earthY;
        const mAng = Math.atan2(mdy, mdx), mDist = Math.sqrt(mdx*mdx + mdy*mdy);
        let mDiff = mAng - personAngle; while (mDiff < -Math.PI) mDiff += Math.PI * 2; while (mDiff > Math.PI) mDiff -= Math.PI * 2;
        if (Math.abs(mDiff) < Math.PI / 2) queue.push({ type: 'mars', dist: mDist, diff: mDiff, ang: mAng, pAng: marsAngle });
    }

    queue.sort((a, b) => b.dist - a.dist).forEach(obj => {
        const x = vCanvas.width / 2 + Math.sin(obj.diff) * (vCanvas.width / 2 * 1.1);
        const y = vCanvas.height - Math.cos(obj.diff) * 100;
        vCtx.save(); vCtx.translate(x, y);
        if (obj.type === 'sun') drawPlanetObject(vCtx, 15, 0, false, 0, 'sun');
        else drawPlanetObject(vCtx, 4000/obj.dist, obj.pAng - obj.ang + Math.PI, false, obj.diff, obj.type);
        vCtx.restore();
    });
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
init();
</script>
</body>
</html>

